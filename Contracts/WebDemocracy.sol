/**
 * @title WebDemocracy - Arbitration contract
 * @dev This contract allows to buy DEM tokens and stake them to be elegible as Juror. The Jury can be elegible
 * after staking the DEM tokens. When a staker is selected as Juror for a specific dispute, the Juror must check
 * all the proves updated by the complainants in www.WebDemocracy.com. All the parties will need to log in with their
 * wallet to have access.
 *
 * The Disputes are generated by the complainants from a third contract used for selling a product, a service, etc.
 * To generate a dispute, the complainants have to pay a fee in ethers depending on the time each Jury are going to need
 * to give a honest vote for the case.
 *
 * Once the Jury have voted the winner for the Dispute in the time stipulated, the winner will be able to withdraw
 * the locked funds from the contract where they interacted.
 *
 * You are only elegible as Juror if you stake your tokens with a minimum and a maximum amount specified.
 * The way how the Jury are selected is 100% random, but you can have more chances to be selected depending on the amount
 * of tokens staked and the Honesty score.
 *
 * The Jury receive +1 in their honesty score every time they voted to the winner of the dispute, and every time they
 * choose to the looser complainant they will receive -1.
 *
 * This contract keeps track of:
 *      Tokens & Staking
 *      Honesty score
 *      Jury selection
 *      Disputes & votes & results.
 *
 * NOTE: To be able to generate a dispute from a Smart contract, that smart contract needs to import the WebDemocracy.sol
 *       contract. This contract imports ERC20.sol, Ownable.sol and Ecommerce.sol.
 */

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts@4.5.0/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts@4.5.0/access/Ownable.sol";
import "./Ecommerce.sol";

contract WebDemocracy is ERC20, Ownable {
    //**********************//
    //   Enums and Structs  //
    //**********************//
    enum DisputeStatus {
        Pending, // When the dispute is under voting.
        Voted, // When the dispute has finished, but the complainants can apelate. 
        UnderApelation // When the dispute is under Apelation.
        Finished, // When the dispute is finished and there is a final winner.
    }

    struct Dispute {
        address buyer; // The buyer in the Smartcontract under Arbitrage.
        address seller; // The seller in the Smartcontract under Arbitrage.
        Ecommerce disputaSC; // Arbitrage contract. (The contract that started the dispute)
        uint disputeID; // Identificator for the Dispute ID.
        bool active; // Toggle to check if the Dispute is active or finished.
        uint256 comision; // Total comision paid by the complainants. (1/2 will be shared to WD and the Jury)
        uint8 buyerCount; // Votes count for the buyer
        uint8 sellerCount; // Votes count for the seller.
        uint timeToVote; // Total time to place the vote.
        DisputeStatus disputeStatus; // Actual status for the dispute.
    }

    //**********************//
    //       Variables      //
    //**********************//

    /* Variables which should not change after initialization.*/
    address payable webDemocracy; // Our own address, to get the 3% of comissions

    /* Variables which will subject to the governance mechanism.*/
    uint public disputesCounter; // Total disputes created.
    uint public penaltiFee = 100; // Penalty fee for no voting in time.
    uint public tokenPrice = 0.0001 ether;
    uint public arbitrationFeePerJuror = 0.005 ether; // Fee per juror.
    uint public protocolFee = 3; // WebDemocracy Fee %.
    bool public sellingTokens; // Toggle to sell or stop selling tokens.
    bool public protocolActive; // Toggle to accept or not accept new Disputes.

    /* Dispute levels.*/
    uint easy = block.timestamp + 1 days; // Easy level.
    uint intermediate = block.timestamp + 1 weeks; // Intermediate level.
    uint dificult = block.timestamp + 4 weeks; // Dificult level.


    //**********************//
    //        Arrays        //
    //**********************//

    address[] public stakers; // Array to track the stakers.

    //**********************//
    //       Mapping        //
    //**********************//

    mapping(address => uint256) public tokensStaked;                 // Juror address => tokens staked (uint)
    mapping(uint => Dispute) public disputeInfo;                     // DisputeID => Dispute info => Dispute details.
    mapping(uint => mapping(address => bool)) public disputeActive;  // DisputeID => Dispute (address) => Dispute active (boolean)
    mapping(uint => address) public winner;                          // DisputeID => winner;
    mapping(address => bool) public jurorStaking;                    // Juror address => Juror staking (boolean)
    mapping(address => bool) public stakedOnce;                      // Juror address => Juror staked at least once (boolean)
    mapping(uint => address[]) juryDispute;                          // DisputeID => Jury selected for that dispute (Array with addresses)
    mapping(uint => mapping(uint8 => address[])) public juryDisputeCount; // DisputeID => voting Choice(1 Buyer, 2 Seller) => Jury voted (Array with addreses)
    mapping(address => int) public honestyScore;                     // Juror address => honesty Score (int + or -)
    mapping(uint => mapping(address => bool)) rightToVote;           // Dispute ID => Jury address => Juror has rights to vote (boolean)
    mapping(address => mapping(uint => uint8)) jurorVoted;           // Jury address => disputeID => voting Choice (1 Buyer, 2 Seller)
    mapping(address => bool) underDispute;                           // Jury address => Juror under dispute. (Boolean)


    //**********************//
    //        Events        //
    //**********************//

    /**
        @dev Emited when a new dispute is generated.
        @param buyer: The buyer in the Smartcontract under Arbitrage.
        @param seller: The seller in the Smartcontract under Arbitrage.
        @param disputeID: new ID generated for this specific Dispute.
        @param timetoFinish: Total time stablished to vote.
    */
    event DisputeGenerated(
        address indexed buyer,
        address indexed seller,
        uint disputeID,
        uint timeToFinish
    );

    /**
        @dev Emited when a new purchase of DEM has been done.
        @param buyer: The buyer of the tokens DEM.
        @param amount: Amount purchased.
    */
    event TokenPurchased(address buyer, uint amount);

    /**
        @dev Emited when a new Jury is generated.
        @param disputeID: ID representing the dispute.
        @param jurys: Array of the jury selected for the dispute.
    */
    event JuryGenerated(uint disputeID, address[] indexed jurys);

    /**
        @dev Emited when a Juror is revocated.
        @param jurorRevocated: Address of the Juror removed from the dispute.
        @param newJuror: Address of the new Juror added to the dispute.
        @param disputeID: ID representing the dispute.
    */
    event JurorRevocated(
        address indexed jurorRevocated,
        address indexed newJuror,
        uint disputeID
    );

    /**
        @dev Emited when a new staker stakes.
        @param staker: Address staking DEM.
        @param amount: Amount of tokens DEM staked.
    */
    event newStaker(address indexed staker, uint amount);

    /** 
        @dev Emited when a dispute has finished.
        @param disputeID: ID representing the dispute.
        @param winner: Address selected as winner in the dispute.
    */
    event DisputeFinished(uint disputeID, uint8 winner);

    /**
     * @dev Constructor.
     * @param _webDemocracy: Protocol address and Owner.
     * @param webDemocracy: ERC20 token Name.
     * @param DEM: ERC20 token Symbol.
     */
    constructor(address payable _webDemocracy) ERC20("WebDemocracy", "DEM") {
        _mint(address(this), 1000000000000000000000000000); // 1billion + 18 decimals
        webDemocracy = _webDemocracy;
    }

    /* 
        @dev Function used to buy tokens when we launch the private round. It will update the holder and the contract balance.
    */
    function buyTokens(uint _amount) public payable {
        require(sellingTokens, "Use DEX and CEX to buy DEM");
        uint price = _totalPrice(_amount);
        require(msg.value >= price);
        uint extra = msg.value - price;
        payable(tx.origin).transfer(extra);

        emit TokenPurchased(msg.sender, _amount);
    }

    // @dev Internal function to get the total price, checking the actual price of the token.
    function _totalPrice(uint _amount) internal view returns (uint) {
        return _amount * tokenPrice;
    }

    // @dev It returns the total balance of the Smart contract in Ethers.
    function balanceOfSc() public view returns (uint) {
        return address(this).balance;
    }

    // @dev Mint function to generate new tokens and add them to the contract balance.
    function mint(uint _amount) public onlyOwner {
        _mint(address(this), _amount);
    }

    // @dev Burn function to transfer tokens from the contract balance to the address(0).
    function burn(uint _amount) public onlyOwner {
        _burn(address(this), _amount);
    }

    /* @dev Setter for the stake token array. 
            The minimum to stake is the penalty fee and the maximum staked is the 3% of total supply.
    */
    function stake(uint _amount) public {
        require(
            balanceOf(msg.sender) >= _amount,
            "You do not have enough tokens to stake"
        );
        require(
            _amount >= penaltiFee,
            "You need to stake at least the penaltiFee"
        ); // Minimum to stake is the penalty fee
        require(
            (_amount + tokensStaked[msg.sender]) < totalSupply() * (3 * 100),
            "Maximum to stake is 3% of the totalSupply"
        );
        // Transfer the tokens to the main contract to be staked
        _transfer(msg.sender, address(this), _amount);
        // Add him to the stakers array if it is the first time the user stakes
        uint _tokensStaked = _checkTokensStaked();
        if (_tokensStaked == 0 && !stakedOnce[msg.sender]) {
            stakers.push(msg.sender);
            stakedOnce[msg.sender] = true;
            emit newStaker(msg.sender, _amount);
        }
        // Update mapping stakers
        tokensStaked[msg.sender] += _amount;
        jurorStaking[msg.sender] = true;
    }

    /*
        @dev Unstake function. It can only be called when you are not underDispute, 
        then, we can substract fees in case the Jury did not vote. 
    */
    function unStake(uint _amount) public {
        require(
            tokensStaked[msg.sender] > 0,
            "You do not have any tokens staked"
        );
        require(
            !underDispute[msg.sender],
            "You cannot unstake until you voted your disputes"
        );
        // Update mapping tokenStaked
        tokensStaked[msg.sender] -= _amount;
        // Transfer the tokens back to the staker
        _transfer(address(this), msg.sender, _amount);
        jurorStaking[msg.sender] = false;

        if (tokensStaked[msg.sender] == 0) {
            jurorStaking[msg.sender] = false;
        }
    }

    /*
        @dev this function will start the Claim and all the needed process as generate random Judge and storing all the dispute details.
            The disputes are set (by now) as easy, to get 24 hours from the block.timeStamp.
    */
    function generateDispute(
        address _comprador,
        address _vendedor,
        uint24 _dificulty,
        uint8 _judgesNeed
    ) external payable {
        require(
            msg.value >= arbitrationFeePerJuror * _judgesNeed,
            "Not enough ETH to pay the Jurys fee."
        );
        require(protocolActive, "The protocol is under maintenance...");

        Dispute memory dispute = Dispute(
            _comprador,
            _vendedor,
            Ecommerce(msg.sender),
            disputesCounter,
            true,
            msg.value,
            0,
            0,
            easy,
            DisputeStatus.Pending
        );
        disputeInfo[disputesCounter] = dispute;

        disputesCounter++;

        emit DisputeGenerated(
            _comprador,
            _vendedor,
            disputesCounter,
            _dificulty
        );
    }

    /*
        @dev WebDemocracy.org will listen to the event DisputeGenerated() and will generate random Judges to the dispute.
            Depending on the number of tokens staked and the Jury honesty score.
    */
    function storeJurys(uint _disputeID, address[] memory _jurysSelected)
        public
        onlyOwner
    {
        juryDispute[_disputeID] = _jurysSelected;

        for (uint i; i > _jurysSelected.length; i++) {
            rightToVote[_disputeID][_jurysSelected[i]] = true;
            underDispute[_jurysSelected[i]] = true; // It will store the Jury as underDispute to do not allow unstake.
        }

        emit JuryGenerated(_disputeID, _jurysSelected);
    }

    /*
        @dev Remove Jurors from the jurors selected
            When the event judgeRevocated is triggered the WebDemocracy will select a new jury and will store it,
            using the function storeJurys()
        @param judgeRevocated will be the juror we want to remove
    */
    function revocateJuror(
        address _jurorRevocated,
        address _newJuror,
        uint _disputeID
    ) public onlyOwner {
        uint nbJudgesDispute = juryDispute[_disputeID].length;

        for (uint i; i < nbJudgesDispute; i++) {
            if (juryDispute[_disputeID][i] == _jurorRevocated) {
                delete juryDispute[_disputeID][i];
            }
        }

        emit JurorRevocated(_jurorRevocated, _newJuror, _disputeID);
    }

    /*
     *  @dev Penalice the penaltiFee to the jurors who did not vote.
     *  @param _jurorAddress Address of the juror to substract tokens.
     *  @param _disputeID The ID of the dispute the juror was drawn.
     *  @param _draws The list of draws the juror was drawn. Numbering starts at 1 and the numbers should be increasing.
     */
    function penalizeInactiveJuror(address _jurorAddress, uint _disputeID)
        public
        onlyOwner
    {
        require(
            disputeInfo[_disputeID].timeToVote < block.timestamp,
            "Must be called after the voting time."
        );
        require(
            tokensStaked[_jurorAddress] >= penaltiFee,
            "Juror does not have enough staking for the fee"
        );

        honestyScore[_jurorAddress] -= 1;

        uint totalVotes = disputeInfo[_disputeID].buyerCount +
            disputeInfo[_disputeID].sellerCount;
        uint penaltiFeeEachJury = totalVotes / penaltiFee; // Jurys who voted share the penaltiFee.
        tokensStaked[_jurorAddress] -= penaltiFee; // Fee will be taken from the juror staking.

        for (uint i; i < totalVotes; i++) {
            if (juryDispute[_disputeID][i] != _jurorAddress) {
                address juror = juryDispute[_disputeID][i];
                tokensStaked[juror] += penaltiFeeEachJury;
            }
        }
    }

    /* @dev function to vote and if you are the last voter it will set the winner. Option 1- Winner, 2- Seller, 3- More time.
        The disputeID and the judge is stored in a mapping with its choose for the winner.
       @IMPROVEMENT we can add the Apleation option (depending if it is a possibility)
    */
    function vote(uint _disputeID, uint8 _choose) public {
        require(
            block.timestamp < disputeInfo[_disputeID].timeToVote,
            "The tieme to vote is over, you will be penalized..."
        );
        require(
            rightToVote[_disputeID][msg.sender] == true,
            "You are allowed to vote for this dispute"
        );
        require(_choose == 1 || _choose == 2, "This option is not available");
        bool votesNeeded = (disputeInfo[_disputeID].buyerCount +
            disputeInfo[_disputeID].sellerCount) == 3;
        jurorVoted[msg.sender][_disputeID] = _choose;

        if (_choose == 1) {
            disputeInfo[_disputeID].buyerCount += 1;

            if (votesNeeded) {
                disputeInfo[_disputeID].active = false;

                emit DisputeFinished(_disputeID, _choose);
            }
        } else if (_choose == 2) {
            disputeInfo[_disputeID].sellerCount += 1;

            if (votesNeeded) {
                disputeInfo[_disputeID].active = false;

                emit DisputeFinished(_disputeID, _choose);
            }
        }
    }

    /*  @dev This function will be called when the needed votes are filled. It will transfer the rewards to the jurys and
            the paid protocol fee back to the winner. 3% to the protocol and 1/3 of the rest to each jury.

            The protocol will call this function and we will take care of the fees for the withdrawal. If not, the jurys 
            should take care of the fees.

            To be triggered, it will listen to the event DisputeFinished to be called.

            Also, It will penalize to the Jurys who did not vote.
    */
    function withdrawalFees(uint _disputeID) public onlyOwner {
        require(
            !disputeInfo[_disputeID].active,
            "We are still waiting for votes to be able to withdrawal"
        );
        uint funds = disputeInfo[_disputeID].comision;
        uint feeRefund = funds / 2; // Half of the fees paid will be returnd to the winner.
        uint feeProtocol = (feeRefund * protocolFee) / 100; // WD keeps 3% of the fee paid from the looser.
        uint8 winnerNum;
        uint8 looserNum;
        address winnerAddress;
        uint8 votedBuyer = disputeInfo[_disputeID].buyerCount;
        uint8 votedSeller = disputeInfo[_disputeID].sellerCount;

        payable(webDemocracy).transfer(feeProtocol); // Payment for WD
        payable(winnerAddress).transfer(feeRefund); // Fees back to the winner
        (disputeInfo[_disputeID].disputaSC).setWinner(winnerAddress); // Set winner to be able to withdraw his funds from the Ecommerce contract.

        if (votedBuyer > votedSeller) {
            winnerNum = 1;
            looserNum = 2;
            winnerAddress = disputeInfo[_disputeID].buyer;

            uint rewardEach = (feeRefund - feeProtocol) / votedBuyer;

            for (uint i; i < votedBuyer; i++) {
                payable(juryDisputeCount[_disputeID][winnerNum][i]).transfer(
                    rewardEach
                );
                honestyScore[juryDisputeCount[_disputeID][winnerNum][i]] += 1;
            }

            for (uint i; i < votedSeller; i++) {
                penalizeInactiveJuror(
                    juryDisputeCount[_disputeID][looserNum][i],
                    _disputeID
                );
            }
        } else {
            winnerNum = 2;
            looserNum = 1;

            winnerAddress = disputeInfo[_disputeID].seller;

            uint rewardEach = (feeRefund - feeProtocol) / votedSeller;

            for (uint i; i < votedSeller; i++) {
                payable(juryDisputeCount[_disputeID][winnerNum][i]).transfer(
                    rewardEach
                );
                honestyScore[juryDisputeCount[_disputeID][winnerNum][i]] += 1;
            }

            for (uint i; i < votedBuyer; i++) {
                penalizeInactiveJuror(
                    juryDisputeCount[_disputeID][looserNum][i],
                    _disputeID
                );
            }
        }
    }

    //
    // @dev this function will change the total price per token.
    function updateTokenPrice(uint _price) public onlyOwner {
        tokenPrice = _price;
    }

    /*
        @dev the address calling this function (msg.sender) will get the total amount of DEM staked.
    */
    function _checkTokensStaked() internal view returns (uint) {
        return tokensStaked[msg.sender];
    }

    /* @dev this function will stop the protocol to generate new Disputes. (It can be used if needed)
     */
    function stopNewDisputes() public onlyOwner {
        protocolActive = false;
    }

    function isActive(address _judge) public view returns (bool) {
        return jurorStaking[_judge];
    }

    /*
        @dev Setter for new fee per Juror.
    */
    function setArbitrationFee(uint _newFee) public onlyOwner {
        arbitrationFeePerJuror = _newFee;
    }

    /*
        @dev Setter for the percentage the Web Democracy Protocol will keep.
    */
    function setWDFee(uint _newFee) public onlyOwner {
        protocolFee = _newFee;
    }

    function _checkProtocolFee() public view returns (uint) {
        return protocolFee;
    }

    /*
        @dev Setter for a new Owner of the contract.
    */
    function setNewOnwer(address payable _newOwner) public onlyOwner {
        webDemocracy = _newOwner;
    }

    /*
        @dev Setter for stop selling tokens when the private round is done.
    */
    function tokenMachine(bool _status) public {
        sellingTokens = _status;
    }

    receive() external payable {}
}
